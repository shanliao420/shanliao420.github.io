# 数据库相关
## 1. Redis跳表实现、查询过程
## 2. redis的淘汰机制、集群部署
## 3. Redis持久化机制

## 2. Mysql B+树
## 8. Mysql XA协议
## 18. Mysql锁（行级锁、列级锁）
## 19. Mysql Mvvc 事务隔离级别，是互斥锁还是乐观锁
## 23. Mysql索引什么时候失效、什么时候加索引、索引在使用时因注意什么？
## 26. Mysql聚簇索引和非聚簇索引的区别

# Go语言相关
## 3. GMP模型
## 4. Go语言map结构
## 5. Go语言chan结构
## 9. Go语言并发编程（互斥锁、条件变量、waitgroup原理）
## 20. Go中引用类型有哪些
## 25. 单例模式（多线程版本）

# 网络通信相关
## 10. gRpc原理
## 13. Http和Https
## 14. tcp连接、关闭连接
## 15. tcp拥塞控制算法
## 22. epoll是什么


# 分布式相关
## 6. 分布式锁实现（Redis和Zookeeper的分布式锁的区别）
## 7. Raft协议

# 操作系统相关
## 16. 线程调度算法
## 17. 内存置换算法
## 21. 常见io，BIO、NIO分别是什么


# 算法相关
## 11. 快速排序实现
## 12. LRU缓存实现
```C++
class node {
public:
    int key;
    int val;
    node *next;
    node() {
        this->key = -1;
        this->val = -1;
        this->next = nullptr;
    }
};


class RealGet{
    public:
    virtual int get(int key);
};

class LRUCache {
public:
    LRUCache(int cap) {
        this->capcity = cap;
        this->head = new node();
        this->len = 0;
    }


    int get(int key) {
        node *p = getByKey(key);
        if (p) {    // 如果已经存在于缓存中，取出值，并将其交换到头部
            switchNode(key, head->next->key);
            return p->val;
        }
        node *newNode = new node();
        newNode->key = key;
        newNode->val = realGet.get(key);    // 从数据库获取值
        if (this->len >= this->capcity) {   // 如果缓存已满，删除尾节点，并将新的节点插入头部
            node *del = this->head;
            while(del->next) {
                del = del->next;
            }
            delete del;
            len--;
        }
        newNode->next = this->head->next;   // 如果缓存未满，直接将新的节点插入头部
        this->head->next = newNode;
        len++;
    }


    node* getByKey(int key) {
        if (this->len <= 0) {
            return nullptr;
        }
        node *p = this->head->next;
        while(p) {
            if (p->key == key) {
                return p;
            }
            p = p->next;
        }
        return nullptr;
    }

    void switchNode(int aKey, int bKey) {
        if (this->len == 0) {
            return;
        }
        if (aKey == bKey) {
            return;
        }
        node *apPre = this->head;
        node *ap = this->head->next;
        while(ap) {
            if (ap->key == aKey) {
                break;
            }
            apPre = apPre->next;
            ap = ap->next;
        }
        node *bpPre = this->head;
        node *bp = this->head->next;
        while (bp) {
            if (bp->key == bKey) {
                break;
            }
            bpPre = bpPre->next;
            bp = bp->next;
        }
        node *temp = bp->next;
        bp->next = ap->next;
        ap->next = temp;
        apPre->next = bp;
        bpPre->next = ap;
    }

private:
    int capcity;
    node *head;
    int len;
    RealGet realGet;

};
```
## 24. 二叉树的遍历（递归、非递归）


