# 20240320[1] didi
## 数据库相关
### 1. Redis跳表实现、查询过程
### 2. redis的淘汰机制、集群部署
### 3. Redis持久化机制

### 2. Mysql B+树
### 8. Mysql XA协议
### 18. Mysql锁（行级锁、列级锁）

在MySQL中有行级锁、表级锁两种原生的锁力度级别：

行级锁：

MySQL中最小的锁粒度级别，可以锁住一行数据，当某个事务需要修改某一行数据时，可以使用行级锁对该数据进行锁定，其他事务直到该锁释放时都无法修改该行数据，行级锁能最大程度保证并发性能，让不同的事务同时修改不同行的数据。

表级锁：

表级锁会锁住整张表，通常在数据表备份、修改等操作时触发。

至于列级锁可以在代码中使用锁机制实现。

```Go
colLock := sync.NewLock()

func updateCol(colName string, id string, value string) {
    colLock.Lock()
    defer colLock.Unlock()
    realUpdateOperation(colName, id, value)
}
```

### 19. Mysql MVCC 事务隔离级别，是互斥锁还是乐观锁

MVCC Multi-Version Concurrency Control 多版本并发控制

用于实现并发访问控制的机制，MVCC允许读取和写入操作同时进行而不会互相阻塞，从而提高数据库的并发性能。

MVCC核心是在数据库中为每一个事务创建一个独立的视图，使得每个事务在读取数据的时候看到的数据版本是一致的，而不受其他事务的影响。

通过以下方式实现MVCC：
1. 快照读 Snapshot Read ： 在读操作时，MVCC会根据事务的开始时间创建一个快照，读取时使用快照来获取数据的版本，快照是一个快照号，数据会携带版本号，通过版本号确定快照数据，从而保证读取的数据与事务开始时的数据是一致的版本。
2. 版本链 Version Chain ： 对于写操作，MVCC会将每次修改的产生的新版本数据保存在版本链中去，同时记录修改的版本号和事务ID，其他事务可以根据版本号和事务ID等信息确定能否看到该版本的数据。
3. 并发控制 Concurrency Control ： 通过版本控制和快照读等机制实现并发控制，确保事务之间的隔离性和一致性，从而避免读操作和写操作之间的互相阻塞。


### 23. Mysql索引什么时候失效、什么时候加索引、索引在使用时因注意什么？

组合索引需要按照最左匹配原则进行查找。

索引添加的时机：
1. 频繁被用于查询条件的列
2. 大表的列，即使没有别频繁用于查询，但一旦关联这个表则最好加上索引
3. 唯一性约束的列

然后就是频繁修改的列、枚举个数极少的列不要加索引，会影响数据库的性能。


### 26. Mysql聚簇索引和非聚簇索引的区别
首先聚簇索引通常是主键索引，聚簇索引直接将数据存储在叶子节点上，聚簇索引要求索引值为唯一标识，聚簇索引在范围查询是有很大的优势，但涉及插入、删除、修改操作较多的数据，会导致索引的重新组织，可能引起性能问题。

而非聚簇索引叶子节点存储的是指向具体数据的指针，可以建立在任意的列上，且可以有多个非聚簇索引，但由于每次都先通过索引找到数据的指针再由其找到具体的数据，增加了额外IO操作，可能导致查询的性能问题。

在MySQL中，非聚簇索引的查找过程：首先定位到B+树上的叶子节点，找到其中的所对应的主键值和偏移量，定位到主键值所在的数据页然后按照偏移量定位到具体的数据。

MySQL数据页的默认大小为16KB

数据页的设计是为了减少IO操作也产生的，比如说聚簇索引，当执行范围查询时，找到对应索引的叶子节点，载入对应的数据页，然后就可以进行向后遍历的操作，以减少IO操作。所以非聚簇索引的多次载入数据页肯定会进行多次IO操作。

## Go语言相关
### 3. GMP模型
### 4. Go语言map结构
### 5. Go语言chan结构
### 9. Go语言并发编程（互斥锁、条件变量、waitgroup原理）
### 20. Go中引用类型有哪些
### 25. 单例模式（多线程版本）

## 网络通信相关
### 10. gRpc原理
### 13. Http和Https
### 14. tcp连接、关闭连接
### 15. tcp拥塞控制算法
### 22. epoll是什么


## 分布式相关
### 6. 分布式锁实现（Redis和Zookeeper的分布式锁的区别）
### 7. Raft协议

## 操作系统相关
### 16. 线程调度算法
### 17. 内存置换算法
### 21. 常见IO，BIO、NIO分别是什么

1. 同步阻塞IO （Sync Blocking IO）

单个线程
同步阻塞IO，应用发起IO，应用会等待IO操作结束在进行其他操作。

2. 同步非阻塞IO （Sync Non-Blocking IO）

单个线程
同步非阻塞IO，应用发起IO，然后继续执行其他任务，应用会通过回调或轮询的方式检查IO操作是否完成。

3. 异步阻塞IO  （Async Blocking IO）

多个线程
异步阻塞IO，应用发起IO，然后等待操作完成，但应用所在的线程不会被阻塞而可以执行其他任务。

4. 异步非阻塞IO （Async Non-Blocking IO）

多个线程
异步非阻塞IO，应用发起IO，然后继续执行其他任务，应用通过回调或轮询的方式检查IO是否完成。

## 算法相关
### 11. 快速排序实现
```C++

int partation(vector<int>& arr, int left, int right) {
    int pivot = left;
    int min_index = left + 1;
    for (int i = left; i < right; i++) {
        if (arr[pivot] >= arr[i]) {
            swap(arr[i], arr[min_index]);
            min_index++;
        }
    }
    min_index--;
    swap(arr[pivot], arr[min_index]);
    return min_index;

}

void quick_sort(vector<int>& arr, int left, int right) {
    if (left >= right) {
        return ;
    }
    int mid = partation(arr, left, right);
    quick_sort(arr, left, mid - 1);
    quick_sort(arr, mid + 1, right);

}


```


### 12. LRU缓存实现
```C++
class node {
public:
    int key;
    int val;
    node *next;
    node() {
        this->key = -1;
        this->val = -1;
        this->next = nullptr;
    }
};


class RealGet{
    public:
    virtual int get(int key);
};

class LRUCache {
public:
    LRUCache(int cap) {
        this->capcity = cap;
        this->head = new node();
        this->len = 0;
    }


    int get(int key) {
        node *p = getByKey(key);
        if (p) {    // 如果已经存在于缓存中，取出值，并将其交换到头部
            switchNode(key, head->next->key);
            return p->val;
        }
        node *newNode = new node();
        newNode->key = key;
        newNode->val = realGet.get(key);    // 从数据库获取值
        if (this->len >= this->capcity) {   // 如果缓存已满，删除尾节点，并将新的节点插入头部
            node *del = this->head;
            while(del->next) {
                del = del->next;
            }
            delete del;
            len--;
        }
        newNode->next = this->head->next;   // 如果缓存未满，直接将新的节点插入头部
        this->head->next = newNode;
        len++;
    }


    node* getByKey(int key) {
        if (this->len <= 0) {
            return nullptr;
        }
        node *p = this->head->next;
        while(p) {
            if (p->key == key) {
                return p;
            }
            p = p->next;
        }
        return nullptr;
    }

    void switchNode(int aKey, int bKey) {
        if (this->len == 0) {
            return;
        }
        if (aKey == bKey) {
            return;
        }
        node *apPre = this->head;
        node *ap = this->head->next;
        while(ap) {
            if (ap->key == aKey) {
                break;
            }
            apPre = apPre->next;
            ap = ap->next;
        }
        node *bpPre = this->head;
        node *bp = this->head->next;
        while (bp) {
            if (bp->key == bKey) {
                break;
            }
            bpPre = bpPre->next;
            bp = bp->next;
        }
        node *temp = bp->next;
        bp->next = ap->next;
        ap->next = temp;
        apPre->next = bp;
        bpPre->next = ap;
    }

private:
    int capcity;
    node *head;
    int len;
    RealGet realGet;

};
```
### 24. 二叉树的遍历（递归、非递归）
```C++




```

